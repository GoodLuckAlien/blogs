## 浏览器eventloop

1.javascript 引擎执行 javascript 是单线程的，因为只有一个 stack 里面有各种正在执行、等待执行的事件。
2.有一些 webAPI 将执行时产生的 callback 放入一个队列，即 “事件队列”。
3.在event loop 循环中不停的将“事件队列”里等待执行的事件，推入 javascript 执行栈。

### 两种任务

宏任务

setTimeout setInterval setImmediate（node） requestAnimationFrame(浏览器)


微任务

process.nextTick(node)  Promise  mutationObserver(浏览器)


1.读取 Macrotask queue 中任务。有俩种情况
任务队列空，向下执行
任务队列不为空，将最先进入的一个（手动+文章加粗）任务推入 javascript 执行栈，向下执行

2.读取 Microtask queue 中任务。有俩种情况
任务队列空，向下执行
任务队列不为空，将最先进入的一个任务推入 javascript 执行栈，并且再次重复此操作（手动+文章加粗），直到 Microtask queue 为空。直白的说：将此任务队列按照先后顺序将所有任务推入javascript 执行栈，向下执行

3.根据本次循环耗时（手动+文章加粗）判断是否需要、是否可以更新UI 【 后面会提一下这个循环时间问题 】
不需要，重复第一步
需要，向下执行
4.更新UI，UI rendering，同时阻塞 javascript 执行。并且继续重复第一步。


## node中的 eventloop

NodeJS 的 event loop 也是有 Macrotask queue 与 Microtask queue 的。只不过 NodeJS 的略有不同。那么主要说说不同在哪里。

NodeJS中 Macrotask queue 与 Microtask queue 实例化到API为：

Macrotask queue --> script(主程序代码)，setImmediate, I/O，setTimeout, setInterval

Microtask queue --> process.nextTick, Promise


宏任务Macrotask queue 不同之处

上面说到了浏览器 event loop 的 Macrotask queue 在每次循环中只会读取一个任务,NodeJS 中 Macrotask queue 会一次性读取完毕（ 同阶段的执行完毕，后面会说到Macrotask queue 分为 6个阶段 ），然后向下读取Microtask。

### 6个阶段

NodeJS 中 Macrotask queue会分为 6 个阶段，每个阶段的作用如下（process.nextTick()在6个阶段结束的时候都会执行）：
timers：执行setTimeout() 和 setInterval()中到期的callback。

I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行
idle, prepare：仅内部使用
poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段
check：执行setImmediate的callback
close callbacks：执行close事件的callback，例如socket.on("close",func)


实现机制不同
nodejs可以理解成4个宏任务和2个微任务队列，但执行宏任务时，有6个步骤
Nodejs中，先执行全局的js代码，执行完同步代码调用栈，清空后，先从微任务队列NextTick queue中依次取出所有的任务，放入调用栈执行；再从微任务队列中的other microtask queue中依次取出所有任务放入调用栈执行。然后开始宏任务的6个阶段，每个阶段都将该宏任务队列中的所有任务都取出来执行，每个宏任务阶段执行完毕后，开始执行微任务，在开始执行下一阶段的宏任务，以此构建事件循环。
Microtask包括：setTimeout\setInterval\setImmediate\requestAnimation\I/O\UI rendering
Microtask包括：process.nextTick(Node)\promise.then()\Object.observe\Mutation.observer


NodeJS 中 Macrotask queue会分为 6 个阶段，每个阶段的作用如下（process.nextTick()在6个阶段结束的时候都会执行）：
timers：执行setTimeout() 和 setInterval()中到期的callback。

I/O callbacks：上一轮循环中有少数的I/Ocallback会被延迟到这一轮的这一阶段执行
idle, prepare：仅内部使用
poll：最为重要的阶段，执行I/O callback，在适当的条件下会阻塞在这个阶段
check：执行setImmediate的callback
close callbacks：执行close事件的callback，例如socket.on("close",func)


实现机制不同
nodejs可以理解成4个宏任务和2个微任务队列，但执行宏任务时，有6个步骤
Nodejs中，先执行全局的js代码，执行完同步代码调用栈，清空后，先从微任务队列NextTick queue中依次取出所有的任务，放入调用栈执行；再从微任务队列中的other microtask queue中依次取出所有任务放入调用栈执行。然后开始宏任务的6个阶段，每个阶段都将该宏任务队列中的所有任务都取出来执行，每个宏任务阶段执行完毕后，开始执行微任务，在开始执行下一阶段的宏任务，以此构建事件循环。
Microtask包括：setTimeout\setInterval\setImmediate\requestAnimation\I/O\UI rendering
Microtask包括：process.nextTick(Node)\promise.then()\Object.observe\Mutation.observer
